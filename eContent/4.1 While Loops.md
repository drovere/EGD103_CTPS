# Iterating an Unknown Number of Times

In a previous reading, we learned about the `for` loop, which is used to either:

- Iterate over a sequence of items (like a `list` or `tuple`), or
- Repeat a block of code a fixed number of times when combined with the `range` function.

However, there are situations where we don't know the number of iterations in advance. For example, we might want to:

- Count up to a number with a certain property (like the first 10 prime numbers), or the first Fibonacci number greater than 1000.
- Keep performing an operation until a certain condition is met (like adding terms of an infinite sequence until a certain threshold).

# The `while` loop

The `while` loop is another control flow statement that allows us to perform operations repeatedly based on a condition. It uses the following syntax:

```python
while condition:
    # Do something
```

:::: note | The `condition`

Here, `condition` is a **boolean expression**, and is checked before each iteration.

If `condition` is `True`, the code block within the loop is executed. This process repeats until condition becomes `False`.

::: note {.danger} | Beware: Infinite loops

If the condition never becomes `False`, the loop will run indefinitely, causing the program to hang. This is called an **infinite loop**.

To avoid infinite loops, ensure that the condition becomes `False` at some point.

:::

If condition is `False` at the start, the code block within the loop is never executed.

::::

For example, the following code will print prime numbers that are less than 10:

```python
def is_prime(number):
    if number <= 1:
        return False
    for divisor in range(2, number): # 2 to number - 1
        if number % divisor == 0:
            # divisible by divisor, so not prime
            return False 
    return True

number = 0
while number < 10:
    if is_prime(number):
        print(number)
    number += 1
```

```plaintext {.output}
2
3
5
7
```

::: details | The `is_prime` function (click to expand)

A **prime number** is a number that is only divisible by 1 and itself. The `is_prime` function returns `True` if the number is prime, and `False` otherwise.

This is done by going through all numbers from 2 to `n-1` (hence the `range(2, n)`), and checking if `n` is divisible by any of them. If it is, the function returns `False` as we found a counterexample.

If none of them are divisible, the function returns `True`.

:::

# Use Cases

To demonstrate the capabilities of the `while` loop, let's consider a few use cases:

## Finding all Fibonacci numbers less than 1000

---

The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. The sequence starts like this: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, and so on.

We can use a `while` loop to find all Fibonacci numbers less than 1000:

```python
fibonacci = [0, 1]
while fibonacci[-1] < 1000:
    fibonacci.append(fibonacci[-2] + fibonacci[-1])
fibonacci = fibonacci[:-1] # remove the last element by slicing
```

```plaintext {.output}
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987]
```

You may replace `1000` with any other number to find all Fibonacci numbers less than that number.

## Convergence of a sequence - Collatz conjecture

---

The [Collatz conjecture](https://en.wikipedia.org/wiki/Collatz_conjecture) is a famous unsolved problem in mathematics. It starts with any positive whole number `n` (i.e., greater than 1), and then:

- If `n` is even, divide it by 2.
- If `n` is odd, multiply it by 3 and add 1.

The conjecture states that no matter what value of `n` we start with, the sequence will always reach 1.

We can use a `while` loop to test this conjecture for a given number:

```python
def collatz_sequence(n):
    sequence = [n] # start with n, and repeat until we reach 1
    while n != 1:
        # if n is even, divide by 2 (integer division)
        if n % 2 == 0:
            n = n // 2
        # if n is odd, multiply by 3 and add 1
        else:
            n = 3 * n + 1
        sequence.append(n)
    return sequence

collatz_sequence(40)
```

```plaintext {.output}
[40, 20, 10, 5, 16, 8, 4, 2, 1]
```

The interesting thing about this sequence is that we don't know how many times we need to repeat the process before we reach 1. When `n = 40`, it took 8 iterations to reach 1, but for `n = 41`, it takes a whopping 110 iterations!

```python
collatz_sequence(41)
```

```plaintext {.output}
[41, 124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
```

## Convergence of a sequence - Euler's number

---

Another famous sequence is the [Euler's number](https://en.wikipedia.org/wiki/E_(mathematical_constant)) (denoted by `e`), which is the base of the natural logarithm. It is defined as the following sum:

$
\begin{aligned}
e &= \sum_{n=0}^{\infty} \frac{1}{n!} \\
  &= \frac{1}{0!} + \frac{1}{1!} + \frac{1}{2!} + \frac{1}{3!} + \frac{1}{4!} + \frac{1}{5!} + \ldots \\
  &= 1 + \frac{1}{1} + \frac{1}{2} + \frac{1}{6} + \frac{1}{24} + \frac{1}{120} + \ldots
\end{aligned}
$

Since the sum is infinite, we can either:

- Stop after a certain number of terms, like `n = 10`, or
- Stop when the difference between two iterations is less than a certain threshold, like `1e-6`.

The first approach is straightforward, and we only need a `for` loop:

```python
import math
e = 0
for n in range(10):
    e += 1 / math.factorial(n)
    print("n =", n, "e =", e)
```

```plaintext {.output}
n = 0 e = 1.0
n = 1 e = 2.0
n = 2 e = 2.5
n = 3 e = 2.6666666666666665
n = 4 e = 2.708333333333333
n = 5 e = 2.7166666666666663
n = 6 e = 2.7180555555555554
n = 7 e = 2.7182539682539684
n = 8 e = 2.71827876984127
n = 9 e = 2.7182815255731922
```

However, the second approach requires a `while` loop, as we don't know how many iterations we need to reach the threshold (like `10**-9`, which is one billionth).

```python
import math
e = 0
n = 0
threshold = 10**-9
previous_e = None
while previous_e is None or abs(e - previous_e) > threshold:
    previous_e = e
    e += 1 / math.factorial(n)
    print("n =", n, "e =", e)
    n += 1
```

```plaintext {.output}
n = 0 e = 1.0
n = 1 e = 2.0
n = 2 e = 2.5
n = 3 e = 2.6666666666666665
n = 4 e = 2.708333333333333
n = 5 e = 2.7166666666666663
n = 6 e = 2.7180555555555554
n = 7 e = 2.7182539682539684
n = 8 e = 2.71827876984127
n = 9 e = 2.7182815255731922
n = 10 e = 2.7182818011463845
n = 11 e = 2.718281826198493
n = 12 e = 2.7182818282861687
n = 13 e = 2.7182818284467594
```

::: details | `None`, `abs`, and `math.factorial` (click to expand)

In order to calculate the difference between two iterations, we need to keep track of the previous value of `e`, which is done using the `previous_e` variable.

Here, the `previous_e` variable is initialised to `None` to indicate that before the first iteration, there is no previous value of `e`.

As a result, the `while` loop is checking if either `previous_e` is `None` (i.e., the first iteration), or the difference between `e` and `previous_e` is greater than the threshold, and if either condition is met, the loop continues.

The `abs` function is used to calculate the absolute value of the difference between `e` and `previous_e`, as we don't want negative differences.

The `math.factorial` function is used to calculate the factorial of `n`, which is defined as:

$$

n! = n \times (n-1) \times (n-2) \times \ldots \times 2 \times 1

$$

:::


# Video Recap

Watch the video below for a recap and demonstration of the above concepts.
