# Why do we need lists and tuples?

In previous lessons, we have seen how to store a single value in a variable, like:

```python
earth_surface_area = 5.1 * 10 ** 8
earth_surface_area
```

```plaintext {.output}
509999999.99999994
```

But what if we want to store multiple values, like the average temperature of each day of the week? We could use a variable for each day, like:

```python
monday_temp = 20
tuesday_temp = 22
wednesday_temp = 25
thursday_temp = 24
friday_temp = 23
saturday_temp = 22
sunday_temp = 19
```

But this is not practical. We would need to create a lot of variables, and it would be hard to work with them. Instead, we can use **lists** or **tuples** to store multiple values in a single variable.

# List Basics

A list is a collection of values. We can create a list by putting the values inside **square brackets** `[]`, **separated by commas**. For example:

```python
temperatures = [20, 22, 25, 24, 23, 22, 19]
temperatures
```

```plaintext {.output}
[20, 22, 25, 24, 23, 22, 19]
```

It is possible to check the length of a list using the `len` function:

```python
len(temperatures)
```

```plaintext {.output}
7
```

## Accessing elements

To access an element of a list, we use the **index** of the element. The index is a number that represents the position of the element in the list.

::: note | Indexes start at `0`

Like most programming languages, Python uses **zero-based indexing**. This means that the first element of the list has index 0, the second element has index 1, and so on.

This means, given a list of `n` elements, the indexes go from `0` to `n-1`.

:::

To access an element of a list, we use the index of the element inside square brackets, like **`[index]`**. For example, to access the temperature of Tuesday (i.e., the second day), we use:

```python
temperatures[1]
```

```plaintext {.output}
22
```

It is also possible to access elements using negative indexes. The last element of the list has index `-1`, the second-to-last element has index `-2`, and so on. For example, to access the temperature of Sunday (i.e., the last day), we use:

```python
temperatures[-1]
```

```plaintext {.output}
19
```

By accessing an element using its index, we can also change its value by **assigning a new value** to it. For example, to change the temperature of Wednesday to 26 (from 25), we use:

```python
temperatures[2] = 26
temperatures
```

```plaintext {.output}
[20, 22, 26, 24, 23, 22, 19]
```

To aid with finding the index of an element, we can use the `index` method, passing the value as an argument:

```python
# The index of 22 is 1 (second element)
temperatures.index(22)
```

```plaintext {.output}
3
```

## Adding an element

There are two ways to add an element to a list - `append` to add to the **end** of the list, and `insert` to add at a **specific position**.

To add an element to the end of the list, we use the `append` method:

```python
temperatures.append(18)
temperatures
```

```plaintext {.output}
[20, 22, 26, 24, 23, 22, 19, 18]
```

To add an element at a specific position, we use the `insert` method, passing the index and the value as arguments:

```python
# 27 will be the 4th element, shifting the other elements to the right
temperatures.insert(3, 27)
temperatures
```

```plaintext {.output}
[20, 22, 26, 27, 24, 23, 22, 19, 18]
```

## Removing an element

There are also two ways to remove an element from a list - `remove` to remove a **specific value**, and `pop` to remove an element at a **specific position**.

To remove a specific value from the list, we use the `remove` method, passing the value as an argument:

```python
temperatures.remove(27)
temperatures
```

```plaintext {.output}
[20, 22, 26, 24, 23, 22, 19, 18]
```

Trying to remove a value that does not exist in the list will raise an error.

```python
temperatures.remove(21)
```

```python {.error}
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Cell In[4], line 1
----> 1 temperatures.remove(21)
      2 temperatures

ValueError: list.remove(x): x not in list
```

To remove an element at a specific position, we use the `pop` method, passing the index as an argument:

```python
# 26 (the 3rd element) will be removed
temperatures.pop(2)
temperatures
```

```plaintext {.output}
[20, 22, 24, 23, 22, 19, 18]
```

## Slicing

We can also access multiple elements of a list at once using **slicing**. To slice a list, we use the **colons** `:` to separate the start, stop, and step indexes. For example, to get the temperatures of every other day, starting from Tuesday (i.e., the second day) and ending on Friday (i.e., the fourth day), we use:

```python
temperatures = [20, 22, 25, 24, 23, 22, 19]
temperatures[1:5:2]
```

```plaintext {.output}
[22, 24]
```

::: note | *In-place* and *out-of-place* operations

When slicing the list, a **new list** is created with the sliced elements, and the original list is **not modified**.

```python
temperatures = [20, 22, 25, 24, 23, 22, 19]
temperatures[1:5:2]
```

```plaintext {.output}
[22, 24]
```

```python
temperatures
```

```plaintext {.output}
[20, 22, 25, 24, 23, 22, 19]
```

In contrast, when using the `append`, `insert`, `remove`, and `pop` methods, the original list is **modified**.

:::

It is possible to omit the start, stop, or step indexes.

For example, we can omit the step index to get every element between the start and stop indexes:

```python
temperatures[1:5]
```

```plaintext {.output}
[22, 25, 24, 23]
```

Omitting the start index will start from the beginning, for example to get the first three temperatures:

```python
temperatures[:3]
```

```plaintext {.output}
[20, 22, 25]
```

Omitting the stop index will go until the end, for example to get the last three temperatures (note the negative index):

```python
temperatures[-3:]
```

```plaintext {.output}
[23, 22, 19]
```

Omitting both the start and stop, but using a negative step index, will create a reversed list:

```python
temperatures[::-1]
```

```plaintext {.output}
[19, 22, 23, 24, 25, 22, 20]
```

# Sequence Operations

There are several functions that can be used with lists, like `max`, `min`, `sum`, etc.

The `max` function returns the maximum value of the list:

```python
max(temperatures)
```

```plaintext {.output}
25
```

The `min` function returns the minimum value of the list:

```python
min(temperatures)
```

```plaintext {.output}
19
```

The `sum` function returns the sum of the list:

```python
sum(temperatures)
```

```plaintext {.output}
155
```

::: note | Functions vs. Methods

We have seen that use `append`, `remove`, `insert`, etc. on a list, we use the **dot operator** to call them, like `temperatures.append(18)`, `temperatures.remove(27)`, etc. These methods are specific to lists.

In contrast, the `max`, `min`, and `sum` functions are **general functions** that can be used with any kind of **sequence**, like lists, tuples, sets, etc. They do not use the dot operator, and are called with the sequence as an argument, like `max(temperatures)`, `min(temperatures)`, etc.

:::

Another operation that can be used with a sequence is the `in` operator (also called the **membership operator**), which checks if a value is present in the sequence:

```python
25 in temperatures
```

```plaintext {.output}
True
```

```python
30 in temperatures
```

```plaintext {.output}
False
```

# Tuples

Similar to lists, tuples are also a collection of values. We can create a tuple by putting the values inside **parentheses** `()`, **separated by commas**. For example:

```python
# Width and height of a rectangle
rect_dimensions = (10, 20)
rect_dimensions
```

```plaintext {.output}
(10, 20)
```

The major difference between lists and tuples is that lists are **mutable** (i.e., we can change their elements), while tuples are **immutable** (i.e., we cannot change their elements). For example:

```python
rect_dimensions[0] = 15
```

```python {.error}
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Cell In[2], line 1
----> 1 rect_dimensions[0] = 20
      2 rect_dimensions

TypeError: 'tuple' object does not support item assignment
```

Additionally, tuples **cannot be modified** using the `append`, `insert`, `remove`, and `pop` methods.

```python
rect_dimensions.append(30)
```

```python {.error}
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
Cell In[3], line 1
----> 1 rect_dimensions.append(30)

AttributeError: 'tuple' object has no attribute 'append'
```

::: note | When to use lists and tuples

You may be wondering, if tuples are so limited, why use them at all?

The main reason is that tuples are **faster** than lists. This is because tuples are **immutable**, and this allows Python to make some optimizations that are not possible with lists.

For example, we could use the `%timeit` magic command to compare the time it takes to create a list and a tuple with the same elements:

```python
%timeit my_list = [1, 2, 3, 4]
```

```plaintext {.output}
27.7 ns ± 0.353 ns per loop (mean ± std. dev. of 7 runs, 10,000,000 loops each)
```

```python
%timeit my_tuple = (1, 2, 3, 4)
```

```plaintext {.output}
8.95 ns ± 0.103 ns per loop (mean ± std. dev. of 7 runs, 100,000,000 loops each)
```

As we can see, creating a tuple is about **3 times faster** than creating a list.

Additionally, when we know that a collection of values will not change, using a tuple is **safe**, as it prevents accidental changes to the elements.

Of course, if there is a need to change the elements, then a list should be used.

:::

# Video Recap

Watch the video below for a recap and demonstration of the above concepts.
