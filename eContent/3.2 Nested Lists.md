# Multi-dimensional lists

In the previous section, we saw that a list can contain any type of data, including other lists. We call these **nested**, or **multi-dimensional** lists.

For example, we can create a list of lists to represent a 2D grid:

```python
# A 2x3 grid
grid = [
    [1,2,3],
    [4,5,6]
]
grid
```

```plaintext {.output}
[[1, 2, 3], [4, 5, 6]]
```

In this case, each element of `grid` is a list itself, and can be accessed via an index:

```python
grid[0]
```

```plaintext {.output}
[1, 2, 3]
```

```python
grid[1]
```

```plaintext {.output}
[4, 5, 6]
```

This also means that if we want to access a single element (e.g. `4`), we need to use two indexes:

```python
grid[1][0] # Second inner list, first element
```

```plaintext {.output}
4
```

# Lists of tuples

Extending the concept of nested lists, a list can also contain tuples as elements. For example:

```python
points = [
    (1, 2),
    (3, 4),
    (5, 6)
]
points
```

```plaintext {.output}
[(1, 2), (3, 4), (5, 6)]
```

Again, each element of `points` is a tuple, and can be accessed via an index:

```python
points[0]
```

```plaintext {.output}
(1, 2)
```

Similar to a list of lists, if you wish to access a single element of a tuple, you can use two indexes:

```python
x = points[0][0]
y = points[0][1]
x, y
```

```plaintext {.output}
(1, 2)
```

::: note | Destructuring assignment

When there is a need to assign the elements of a tuple to individual variables, Python allows for a more concise syntax called **destructuring assignment**. For example:

```python
x, y = points[0]
x, y
```

```plaintext {.output}
(1, 2)
```

This assignment can also be used for lists:

```python
first, second, third = [1, 2, 3]
first, second, third
```

```plaintext {.output}
(1, 2, 3)
```

However, the number of variables must match the number of elements in the list or tuple. For example, the following code will raise an error:

```python
first, second = [1, 2, 3]
```

```python {.error}
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Cell In[14], line 1
----> 1 x, y, z = [1, 2, 3, 4]
      2 x, y, z

ValueError: too many values to unpack (expected 3)
```

Similarly, the following code will also raise an error:

```python
a, b, c, d = [1, 2, 3]
```

```python {.error}
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Cell In[15], line 1
----> 1 a, b, c, d = [1, 2, 3]

ValueError: not enough values to unpack (expected 4, got 3)
```

:::

# Video Recap

Watch the video below for a recap and demonstration of the above concepts.
